#!/usr/bin/env python3.7
# -*- coding: utf-8 -*-
"""
Prometheus Exporter for Open Weather API
"""
import os
import sys
import time
import re
import logging
import argparse
from unicodedata import normalize
import yaml
from pyowm.owm import OWM
from prometheus_client import start_http_server
from prometheus_client.core import GaugeMetricFamily, REGISTRY
from systemd.journal import JournaldLogHandler

ow_metric_dict = {}
script_name = os.path.basename(sys.argv[0])
script_instance = os.uname()[1]

# Dealing with command line options

parser = argparse.ArgumentParser()

parser.add_argument(
    '-p',
    '--port',
    help='Port, default: 8080',
    nargs='?',
    const=8080,
    type=int,
    default=8080)

parser.add_argument(
    '-c',
    '--config',
    help='Path to config file')

args = parser.parse_args()

if len(sys.argv) == 1:
    parser.print_help()
    sys.exit(1)

port_number = args.port
app_config = args.config

# Handle with config file

# Loggin to Journalctl
logger = logging.getLogger(script_name)
journaldHandler = JournaldLogHandler()
journaldHandler.setFormatter(logging.Formatter('[%(levelname)s] %(message)s'))
logger.addHandler(journaldHandler)
logger.setLevel(logging.INFO)

try:
    config = yaml.full_load(open(app_config))
    ow_api_key = config['api_key']
    city_dict = dict(config['location']['cities'])

except OSError as exit_error:
    logger.error("no configuration file found: %s", exit_error.strerror)
    sys.exit(1)

class OpenWeatherCollector(object):
    """
    Class to be called from mais function and working as a server, like prometheus_client examples
    """
    def collect(self):
        """
        Function that does almost everything, like prometheus_client examples
        """
        ow_manager = OWM(ow_api_key)
        ow_weather_manager = ow_manager.weather_manager()
        logger.info("starting collection of weather data from city list")

        for configured_city_name, configured_city_value in city_dict.items():
            # Support new config format: city -> {lat: float, lon: float}
            # If old format (numeric city id) is detected, skip with a warning
            if isinstance(configured_city_value, dict) and 'lat' in configured_city_value and 'lon' in configured_city_value:
                lat = configured_city_value['lat']
                lon = configured_city_value['lon']
            else:
                logger.warning(
                    "city '%s' configured with legacy city ID '%s'. Please provide 'lat' and 'lon' to use One Call API.",
                    configured_city_name, str(configured_city_value)
                )
                continue

            # Normalize city label
            city_label = re.sub(' ', '_', normalize('NFKD', configured_city_name).encode('ASCII','ignore').decode('ASCII').lower())

            # Location Metrics
            logger.info("collection location data for %s", configured_city_name)
            ow_metric_dict.update({'openweather_location_lat': lat})
            ow_metric_dict.update({'openweather_location_lon': lon})

            # Weather Metrics via One Call (current)
            logger.info("collection weather data for %s", configured_city_name)
            one_call = ow_weather_manager.one_call(lat=lat, lon=lon, units='metric')
            current_weather = one_call.current

            ow_weather_dict_wind = current_weather.wind()
            ow_weather_dict_temperature = current_weather.temperature('celsius')
            ow_metric_dict.update({'openweather_cloudiness': current_weather.clouds})
            ow_metric_dict.update({'openweather_humidity': current_weather.humidity})
            ow_metric_dict.update({'openweather_temperature': ow_weather_dict_temperature['temp']})
            ow_metric_dict.update({'openweather_pressure': current_weather.pressure['press']})
            ow_metric_dict.update({'openweather_sunrise': current_weather.sunrise_time()})
            ow_metric_dict.update({'openweather_sunset': current_weather.sunset_time()})
            ow_metric_dict.update({'openweather_visibility': current_weather.visibility_distance})
            ow_metric_dict.update({'openweather_windspeed': ow_weather_dict_wind.get('speed')})
            ow_metric_dict.update({'openweather_winddegree': ow_weather_dict_wind.get('deg')})

            for dict_key in ow_metric_dict:
                help_text = 'collecting {} metrics for {}'.format(dict_key, city_label)
                ow_metric_value = ow_metric_dict[dict_key]
                ow_metric_constructor = GaugeMetricFamily(
                    dict_key, help_text, labels=['type', 'instance', 'job', 'city'])
                ow_metric_constructor.add_metric(
                    ['openweather_metrics', script_instance, script_name, city_label],
                    ow_metric_value)
                yield ow_metric_constructor

        logger.info("collection done, taking a nap")

if __name__ == '__main__':
    logger.info("starting app %s", script_name)
    REGISTRY.register(OpenWeatherCollector())
    start_http_server(port_number)
    while True:
        time.sleep(60)
